{
    "contents" : "compute_w <- function(x, param, k, kind=NULL){\n  if (is.null(kind)){\n    kind <- rep(1,ncol(x))\n    for (j in 1:ncol(x)){\n      if (all(x[,j]==ceiling(x[,j]))){\n        if (max(x[,j])==1){\n          kind[j] <- 3\n        }else{\n          kind[j] <- 2\n        }\n      }\n    }\n  }\n  \n  y <- x\n  if (any(kind==1)){\n    for (j in which(kind==1))\n      y[,j] <- (x[,j]-param@margins[[k]][j,1])/param@margins[[k]][j,2]\n  }\n  \n  if (any(kind!=1)){\n    who <- which(kind!=1)\n    for (j in who){\n      if (kind[j]==3){\n        y[,j] <- genere_y_entier(x[,j],param@margins[[k]][j,1])\n      }else if (kind[j]==3){\n        y[,j] <- genere_y_binaire(x[,j],param@margins[[k]][j,1]) \n      }\n    }\n  }\n  \n  \n  sauve <- y\n  for (it in 1:500){\n    if (any(kind!=1)){\n      for (j in who){\n        me <-  rowSums(sweep(as.matrix(y[,-j]), 2, as.numeric(param@correlations[[k]][j,-j] %*% solve(param@correlations[[k]][-j,-j]) ),FUN=\"*\"))\n        sig <- sqrt( param@correlations[[k]][j,j]- param@correlations[[k]][j,-j] %*% solve(param@correlations[[k]][-j,-j])  %*%param@correlations[[k]][-j,j] )\n        \n        \n        if (kind[j]==2){\n          y[,j] <- genere_y_entier2(param@margins[[k]][j,1], x[,j], me, sig)\n        }else if (kind[j]==3){\n          y[,j] <- genere_y_binaire2(param@margins[[k]][j,1], x[,j], me, sig) \n        }\n      }\n    }\n    sauve <- sauve + y\n  }\n  sauve <- as.matrix(sauve /1000)\n  return(sauve)\n}\n\ncompute_cik <- function(obj, class){\n  w <- compute_w(obj@data$data, obj@param, class, obj@data$kind)\n  res.eigen <- eigen(obj@param@correlations[[class]]) \n  return(w%*%res.eigen$vectors)\n}\n\n\n\ndrawn_cik <- function(obj, class, axe){\n  res.eigen <- eigen(obj@param@correlations[[class]]) \n  plot(obj@expect_y[[class]][,axe[1]], obj@expect_y[[class]][,axe[2]],cex.lab=1.5,cex=1,lwd=1.5, col=obj@partition, pch=class+15, \n       xlab=paste(\"inertia\",round(res.eigen$values[axe[1]]/obj@data$ncol*100,1),\"%\"), ylab=paste(\"inertia\",round(res.eigen$values[axe[2]]/obj@data$ncol*100,1),\"%\"))\n  abline(v=0,lty=2)\n  abline(h=0,lty=2)\n}\n\nplot_correl <- function(obj, class, axe){\n  res.eigen <- eigen(obj@param@correlations[[class]]) \n  plot(NA,xlim=c(-1,1),ylim=c(-1,1),cex.lab=1.5,cex=1,lwd=1.5,\n       xlab=paste(\"inertia\",round(res.eigen$values[axe[1]]/obj@data$ncol*100,1),\"%\"), ylab=paste(\"inertia\",round(res.eigen$values[axe[2]]/obj@data$ncol*100,1),\"%\"))\n  plan <- res.eigen$vectors\n  for (j in 1:nrow(plan)){\n    arrows(0,0,plan[j,axe[1]],plan[j,axe[2]],lwd=2)\n    c1 <- plan[j,axe[1]]-0.05+0.1*(plan[j,axe[1]]>0)\n    c2 <- plan[j,axe[2]]-0.05+0.1*(plan[j,axe[2]]>0)\n    text(c1,c2,colnames(obj@data$data)[j],cex=1)\n  }\n  lines(c(0,0),c(-2,2),lty=2)\n  lines(c(-2,2),c(0,0),lty=2)\n  draw.circle(0, 0, radius = 1,lwd=1) \n}\n\nMixClusvisu <- function(obj, class, axe=c(1,2)){\n  op <- par(no.readonly = TRUE)\n  \n  par(mar=c(4.2,4.2,1,1))\n  if (obj@test_expect_y[class]==0){\n    cat(\"  computation of the coordinates\\n\")\n    obj@test_expect_y[class] <- 1\n    obj@expect_y[[class]]  <- compute_cik(obj, class)\n  }\n\n  cat(\"  scatterplot\\n\")\n  drawn_cik(obj, class, axe)\n  cat(\"  correlation circle\")\n  par(mar=c(4.2,3.2,1,1),mfrow=c(1,1),cex.axis=1.5,pty=\"s\")\n  plot_correl(obj, class, axe)\n  \n  \n  \n  par(op)\n  return(obj)\n}\n\n\n\nplot_continue <- function(object, j){\n  main <- colnames(object@data$data)[j]\n  hist(object@data$data[,j], freq=FALSE, main=main, cex.main=2.2, plot=TRUE, xlab=\"\", ylab=\"\",\n       xlim=c(min(object@data$data[,j]), max(object@data$data[,j])))\n  se <- seq(min(object@data$data[,j]),max(object@data$data[,j]),length.out=100)\n  tmp <- se*0\n  for (k in 1:length(object@param@proportions)){\n    tmp <- tmp + object@param@proportions[k]*dnorm(se, object@param@margins[[k]][j,1], object@param@margins[[k]][j,2])\n    lines(se, object@param@proportions[k]*dnorm(se, object@param@margins[[k]][j,1], object@param@margins[[k]][j,2]),col=k,lwd=6)\n  }\n  lines(se,tmp,col=\"grey\",lwd=6,lty=2)\n}\n\nplot_entier <- function(object, j){\n  main <- colnames(object@data$data)[j]\n  se <- min(object@data$data[,j]):max(object@data$data[,j])\n  re <- matrix(0,length(object@param@proportions),length(se))\n  colnames(re) <- min(se):max(se)\n  \n  for (k in 1:length(object@param@proportions)){\n    re[k,] <- object@param@proportions[k]*dpois(se, object@param@margins[[k]][j,1])\n  }\n  barplot(re,col=1:length(object@param@proportions),main=main,cex.main=2.2,\n          plot=TRUE,xlab=\"\",xlim=c(min(se),max(se)+3))\n}\n\n\nplot_binaire <- function(object, j){\n  main <- colnames(object@data$data)[j]\n  proba <- matrix(object@param@proportions,length(object@param@proportions),ncol=2)\n  for (k in 1:nrow(proba))\n    proba[k,] <- proba[k,]*(c(object@param@margins[[k]][j,1],1-object@param@margins[[k]][j,1]))\n  colnames(proba) <- c(\"Prob.0\", \"Prob.1\")\n  mp <- barplot(proba, beside = TRUE, axisnames = TRUE, names.arg=names(t),col=1:nrow(proba),\n                cex.main=2.5)\n  # add unconditional frequencies\n  title(main,cex.main=2.2)\n  # Add the individual bar labels\n  mtext(1, at = mp, text = paste(\"C\",1:nrow(proba)), line = 0, cex = 1)\n}\n\nplot_ordinal <- function(object, j){\n  cat(\"TODO\")\n  plot(NA,xlim=c(0,1),ylim=c(0,1))\n}\n\n\nsetMethod(\n  f=\"plot\",\n  signature=c(\"MixClusresults\"),\n  function(x, y, ...){\n    if (missing(y)){\n      y <- 1: x@data$ncol\n    }\n    \n    if (is.numeric(y)){\n      if (max(y)>x@data$ncol)\n        stop(\"y mismatchs the data frame dimension\")\n    }else{\n      stop(\"y has to be a numeric vector indicating the variables to be plotted\")\n    }\n    # get old par \n    op <- par(no.readonly = TRUE) \n    \n    par(mar = rep(2.5,4),cex = .75)\n    if (length(y)==1){\n      split.screen(c(1,1))\n    }else if (length(y)<=3){\n      split.screen(c(1,length(y)))\n    }else if (length(y)==4){\n      split.screen(c(2,2))\n    }else if (length(y)<13){\n      split.screen(c(length(y)%/%3 + 1*(length(y)!= (3*(length(y)%/%3))),3))\n    }else{\n      split.screen(c(length(y)%/%4 + 1*(length(y)!= (4*(length(y)%/%4))),4))\n    }\n    cp <- 0\n    for ( j in y){\n      cp <- cp+1\n      screen(cp)\n      if (x@data$kind[j]==1){\n        plot_continue(x, j)\n      }else if (x@data$kind[j]==2){\n        plot_entier(x, j)\n      }else if (x@data$kind[j]==3){\n        plot_binaire(x, j)\n      }else if (x@data$kind[j]==4){\n        plot_ordinal(x, j)\n      }\n    }\n    close.screen(all.screens = TRUE)\n    # restore plotting parameters\n    par(op)\n    \n  }\n  \n  \n)\n",
    "created" : 1407922049967.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1443918504",
    "id" : "5A74D6EA",
    "lastKnownWriteTime" : 1407934007,
    "path" : "~/workspace/Copules/R/visualise.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}